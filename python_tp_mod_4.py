# -*- coding: utf-8 -*-
"""Python - Mod4 - TP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d6-2XF12wsYokyrInmSpJHwFJ8alfxFZ

## Trabaçho Prático do Módulo 4 - Desenvolvedor Python
"""

#importando as bibliotecas
import pandas as pd  #bibioteca responsável para o tratamento e limpeza dos dados
import numpy as np #biblioteca utilizada para o tratamento eficiente de dados numéricos
import datetime  #biblioteca utilizada para trabalhar com datas
from matplotlib import pyplot as plt  #plotar os gráficos
import seaborn as sns #plot de gráficos
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split

from google.colab import files  #biblioteca utilizada para carregar os dados para o google colab
uploaded = files.upload()

#realizando a leitura do arquivo (dataset)
nome_do_arquivo="datasets_diabetes.csv"
dataset= pd.read_csv(nome_do_arquivo)

dataset.head()

dataset.describe()

dataset.info()

dataset['Outcome'].value_counts()

#selecionando os dados para a construção da previsão
entradas = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age']
saida=['Outcome']

normaliza = MinMaxScaler() #objeto para a normalização
entradas_normalizadas=normaliza.fit_transform(dataset[entradas])

x=entradas_normalizadas
y=dataset[saida]

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.30,random_state=42)

x_train

"""#KNN"""

#contruindo o modelo para cliassificação com KNN com K=5
from sklearn.neighbors import KNeighborsClassifier
clf_KNN = KNeighborsClassifier(n_neighbors=5)

#treinando o modelo
clf_KNN.fit(x_train, y_train) # aplica a classificação

#realiza a previsão para o KNN
y_pred_KNN = clf_KNN.predict(x_test)

#contrução da matriz de confusão
from sklearn.metrics import classification_report, confusion_matrix

print(classification_report(y_test,y_pred_KNN))

"""#Árvore de Decisão"""

#aplicando um modelo de classificação via árvore de decisão
from sklearn.tree import DecisionTreeClassifier
clf_arvore = DecisionTreeClassifier(random_state=1) 
clf_arvore.fit(x_train, y_train)

#realiza a previsão com os dados
y_previsto = clf_arvore.predict(x_test)

from sklearn.metrics import accuracy_score
acuracia = accuracy_score(y_test, y_previsto)
print('Acurácia da àrvore de Decisão: ',acuracia)

#contrução da matriz de confusão
matriz_confusao = confusion_matrix(y_test, y_previsto)
print(matriz_confusao)

"""#Floresta Randômica"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import make_classification
clf_floresta = RandomForestClassifier(max_depth=10, random_state=1)

clf_floresta.fit(x_train, y_train)

#Acurácia
clf_floresta.score(x_test, y_test)

"""#SVM"""

#importando o svm como classificador
from sklearn.svm import SVC
clf_svm=SVC(gamma='auto',random_state=1)

clf_svm.fit(x_train, y_train)

#Acurácia
clf_svm.score(x_test, y_test)

"""#MLP"""

#MLP como classificador
from sklearn.neural_network import MLPClassifier

#define a configuração da rede
clf_mlp = MLPClassifier(solver='lbfgs', alpha=1e-5, hidden_layer_sizes=(5,5), random_state=1)

#realiza o fit do modelo
clf_mlp.fit(x_train,y_train.values.ravel())

#realiza a previsão
y_pred_mlp=clf_mlp.predict(x_test)

print(classification_report(y_test,y_pred_mlp))

"""#Thread"""

import threading
import time
from random import randint

def funcao_1(num):
  n=num
  while n>0:
    n-=1
    print("n_1: {}".format(n))
    time.sleep(randint(0,2))
		
def funcao_2(num):
  n=num

  while n<100:
    n+=1
    print("n_2: {}".format(n))
    time.sleep(randint(0,2))

if __name__== "__main__":
    
  t1 = threading.Thread(target=funcao_1, args=(100,))	
  t2 = threading.Thread(target=funcao_2, args=(0,))
	
  t1.start()
  t2.start()
	
  t1.join()
  t2.join()
	
  print("Fim!")

